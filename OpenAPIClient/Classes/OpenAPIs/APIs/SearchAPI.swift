//
// SearchAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

open class SearchAPI {
    /**
     * enum for parameter searchTarget
     */
    public enum SearchTarget_searchVideoChannelsGet: String, CaseIterable {
        case local = "local"
        case searchIndex = "search-index"
    }

    /**
     Search channels
     
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete channel information and interact with it.  
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort column (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func searchVideoChannelsGet(search: String, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchVideoChannelsGet? = nil, sort: String? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: [VideoChannel]?, _ error: Error?) -> Void)) {
        searchVideoChannelsGetWithRequestBuilder(search: search, start: start, count: count, searchTarget: searchTarget, sort: sort).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Search channels
     - GET /search/video-channels
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete channel information and interact with it.  
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort column (optional)
     - returns: RequestBuilder<[VideoChannel]> 
     */
    open class func searchVideoChannelsGetWithRequestBuilder(search: String, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchVideoChannelsGet? = nil, sort: String? = nil) -> RequestBuilder<[VideoChannel]> {
        let path = "/search/video-channels"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters: [String: Any]? = nil

        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "search": search.encodeToJSON(),
            "start": start?.encodeToJSON(),
            "count": count?.encodeToJSON(),
            "searchTarget": searchTarget?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<[VideoChannel]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     * enum for parameter nsfw
     */
    public enum Nsfw_searchVideosGet: String, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter filter
     */
    public enum Filter_searchVideosGet: String, CaseIterable {
        case local = "local"
        case allLocal = "all-local"
    }

    /**
     * enum for parameter skipCount
     */
    public enum SkipCount_searchVideosGet: String, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter searchTarget
     */
    public enum SearchTarget_searchVideosGet: String, CaseIterable {
        case local = "local"
        case searchIndex = "search-index"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_searchVideosGet: String, CaseIterable {
        case name = "name"
        case duration = "-duration"
        case createdat = "-createdAt"
        case publishedat = "-publishedAt"
        case views = "-views"
        case likes = "-likes"
        case match = "-match"
    }

    /**
     Search videos
     
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete video information and interact with it.  
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#tag/Video/paths/~1videos~1categories/get)) (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#tag/Video/paths/~1videos~1licences/get)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#tag/Video/paths/~1videos~1languages/get)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter filter: (query) Special filters which might require special rights:  * &#x60;local&#x60; - only videos local to the instance  * &#x60;all-local&#x60; - only videos local to the instance, but showing private and unlisted videos (requires Admin privileges)  * &#x60;all&#x60; - all videos, showing private and unlisted videos (requires Admin privileges)  (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort videos by criteria (optional)
     - parameter startDate: (query) Get videos that are published after this date (optional)
     - parameter endDate: (query) Get videos that are published before this date (optional)
     - parameter originallyPublishedStartDate: (query) Get videos that are originally published after this date (optional)
     - parameter originallyPublishedEndDate: (query) Get videos that are originally published before this date (optional)
     - parameter durationMin: (query) Get videos that have this minimum duration (optional)
     - parameter durationMax: (query) Get videos that have this maximum duration (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func searchVideosGet(search: String, categoryOneOf: OneOfintegerarray? = nil, tagsOneOf: OneOfstringarray? = nil, tagsAllOf: OneOfstringarray? = nil, licenceOneOf: OneOfintegerarray? = nil, languageOneOf: OneOfstringarray? = nil, nsfw: Nsfw_searchVideosGet? = nil, filter: Filter_searchVideosGet? = nil, skipCount: SkipCount_searchVideosGet? = nil, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchVideosGet? = nil, sort: Sort_searchVideosGet? = nil, startDate: Date? = nil, endDate: Date? = nil, originallyPublishedStartDate: Date? = nil, originallyPublishedEndDate: Date? = nil, durationMin: Int? = nil, durationMax: Int? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: VideoListResponse?, _ error: Error?) -> Void)) {
        searchVideosGetWithRequestBuilder(search: search, categoryOneOf: categoryOneOf, tagsOneOf: tagsOneOf, tagsAllOf: tagsAllOf, licenceOneOf: licenceOneOf, languageOneOf: languageOneOf, nsfw: nsfw, filter: filter, skipCount: skipCount, start: start, count: count, searchTarget: searchTarget, sort: sort, startDate: startDate, endDate: endDate, originallyPublishedStartDate: originallyPublishedStartDate, originallyPublishedEndDate: originallyPublishedEndDate, durationMin: durationMin, durationMax: durationMax).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Search videos
     - GET /search/videos
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete video information and interact with it.  
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#tag/Video/paths/~1videos~1categories/get)) (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#tag/Video/paths/~1videos~1licences/get)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#tag/Video/paths/~1videos~1languages/get)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter filter: (query) Special filters which might require special rights:  * &#x60;local&#x60; - only videos local to the instance  * &#x60;all-local&#x60; - only videos local to the instance, but showing private and unlisted videos (requires Admin privileges)  * &#x60;all&#x60; - all videos, showing private and unlisted videos (requires Admin privileges)  (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort videos by criteria (optional)
     - parameter startDate: (query) Get videos that are published after this date (optional)
     - parameter endDate: (query) Get videos that are published before this date (optional)
     - parameter originallyPublishedStartDate: (query) Get videos that are originally published after this date (optional)
     - parameter originallyPublishedEndDate: (query) Get videos that are originally published before this date (optional)
     - parameter durationMin: (query) Get videos that have this minimum duration (optional)
     - parameter durationMax: (query) Get videos that have this maximum duration (optional)
     - returns: RequestBuilder<VideoListResponse> 
     */
    open class func searchVideosGetWithRequestBuilder(search: String, categoryOneOf: OneOfintegerarray? = nil, tagsOneOf: OneOfstringarray? = nil, tagsAllOf: OneOfstringarray? = nil, licenceOneOf: OneOfintegerarray? = nil, languageOneOf: OneOfstringarray? = nil, nsfw: Nsfw_searchVideosGet? = nil, filter: Filter_searchVideosGet? = nil, skipCount: SkipCount_searchVideosGet? = nil, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchVideosGet? = nil, sort: Sort_searchVideosGet? = nil, startDate: Date? = nil, endDate: Date? = nil, originallyPublishedStartDate: Date? = nil, originallyPublishedEndDate: Date? = nil, durationMin: Int? = nil, durationMax: Int? = nil) -> RequestBuilder<VideoListResponse> {
        let path = "/search/videos"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters: [String: Any]? = nil

        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "search": search.encodeToJSON(),
            "categoryOneOf": categoryOneOf?.encodeToJSON(),
            "tagsOneOf": tagsOneOf?.encodeToJSON(),
            "tagsAllOf": tagsAllOf?.encodeToJSON(),
            "licenceOneOf": licenceOneOf?.encodeToJSON(),
            "languageOneOf": languageOneOf?.encodeToJSON(),
            "nsfw": nsfw?.encodeToJSON(),
            "filter": filter?.encodeToJSON(),
            "skipCount": skipCount?.encodeToJSON(),
            "start": start?.encodeToJSON(),
            "count": count?.encodeToJSON(),
            "searchTarget": searchTarget?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "startDate": startDate?.encodeToJSON(),
            "endDate": endDate?.encodeToJSON(),
            "originallyPublishedStartDate": originallyPublishedStartDate?.encodeToJSON(),
            "originallyPublishedEndDate": originallyPublishedEndDate?.encodeToJSON(),
            "durationMin": durationMin?.encodeToJSON(),
            "durationMax": durationMax?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<VideoListResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
